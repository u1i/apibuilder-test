"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function mockmethod(spec, name, ctx) {
	var methd = spec.methods[name];
	if (!methd) {
		throw new Error("failed to find method: " + name);
	}

	var req = { params: {} };
	Object.keys(methd.parameter.properties).forEach(function (param) {
		req.params[param] = ctx[param];
	});

	return new Promise(function (resolve) {
		var cb = function cb() {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			resolve(args);
		};

		Object.keys(methd.outputs).forEach(function (output) {
			cb[output] = function () {
				for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
					args[_key2] = arguments[_key2];
				}

				resolve(_defineProperty({}, output, args));
			};
		});
		methd.action(req, cb);
	});
}

function mocknode(specs, name) {
	var spec = specs[name];
	if (!spec) {
		throw new Error("failed to find spec for: " + name);
	}
	return {
		invoke: mockmethod.bind(null, spec)
	};
}

function mockspecs(node) {
	return {
		node: mocknode.bind(null, node.specs)
	};
}

exports = module.exports = mockspecs;